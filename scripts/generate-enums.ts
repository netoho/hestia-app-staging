#!/usr/bin/env bun
/**
 * Generate client-safe enum definitions from Prisma schema
 * This script extracts enum values from the generated Prisma client
 * and creates a lightweight file that can be safely imported in client components
 */

import { readFileSync, writeFileSync, existsSync } from 'fs';
import { join } from 'path';

const PRISMA_CLIENT_PATH = join(process.cwd(), 'node_modules', '.prisma', 'client', 'index.js');
const OUTPUT_PATH = join(process.cwd(), 'src', 'lib', 'enums.ts');

// List of enums we expect to find (from schema.prisma)
const EXPECTED_ENUMS = [
  'UserRole',
  'TenantType',
  'GuarantorType',
  'PropertyType',
  'NationalityType',
  'PolicyStatus',
  'DocumentCategory',
  'InvestigationVerdict',
  'RiskLevel',
  'PaymentStatus',
  'PaymentMethod',
  'PaymentType',
  'PayerType',
  'ReporterType',
  'IncidentStatus',
  'ActorVerificationStatus',
  'ValidationStatus',
  'RulesType'
];

function extractEnums(): Record<string, Record<string, string>> {
  if (!existsSync(PRISMA_CLIENT_PATH)) {
    throw new Error(
      'Prisma client not found. Please run "bun prisma generate" first.'
    );
  }

  const clientContent = readFileSync(PRISMA_CLIENT_PATH, 'utf-8');

  // Find the $Enums export section
  // Prisma generates enums like: exports.EnumName = exports.$Enums.EnumName = { ... }
  const enumRegex = /exports\.(\w+)\s*=\s*exports\.\$Enums\.\w+\s*=\s*({[^}]+})/g;
  const enums: Record<string, Record<string, string>> = {};

  let match;
  while ((match = enumRegex.exec(clientContent)) !== null) {
    const enumName = match[1];
    const enumValuesStr = match[2];

    // Only process expected enums
    if (!EXPECTED_ENUMS.includes(enumName)) {
      continue;
    }

    try {
      // Parse the enum object
      // It's in the format: { KEY: 'VALUE', KEY2: 'VALUE2' }
      // We need to safely evaluate this
      const enumValues: Record<string, string> = {};

      // Extract key-value pairs using regex
      const pairRegex = /(\w+):\s*['"]([^'"]+)['"]/g;
      let pairMatch;

      while ((pairMatch = pairRegex.exec(enumValuesStr)) !== null) {
        enumValues[pairMatch[1]] = pairMatch[2];
      }

      if (Object.keys(enumValues).length > 0) {
        enums[enumName] = enumValues;
      }
    } catch (error) {
      console.error(`Failed to parse enum ${enumName}:`, error);
    }
  }

  // Verify we found all expected enums
  const foundEnums = Object.keys(enums);
  const missingEnums = EXPECTED_ENUMS.filter(e => !foundEnums.includes(e));

  if (missingEnums.length > 0) {
    console.warn('Warning: Some expected enums were not found:', missingEnums);
  }

  return enums;
}

function generateEnumFile(enums: Record<string, Record<string, string>>): string {
  const lines: string[] = [];

  // Add header
  lines.push(`// AUTO-GENERATED FROM prisma/schema.prisma`);
  lines.push(`// DO NOT EDIT - This file is automatically generated when running 'bun prisma generate'`);
  lines.push(`// Generated at: ${new Date().toISOString()}`);
  lines.push('');
  lines.push('/**');
  lines.push(' * Client-safe enum definitions extracted from Prisma schema');
  lines.push(' * These can be safely imported in both server and client components');
  lines.push(' */');
  lines.push('');

  // Generate each enum
  for (const [enumName, enumValues] of Object.entries(enums)) {
    // Generate const object
    lines.push(`export const ${enumName} = {`);

    const entries = Object.entries(enumValues);
    entries.forEach(([key, value], index) => {
      const comma = index < entries.length - 1 ? ',' : '';
      lines.push(`  ${key}: '${value}'${comma}`);
    });

    lines.push('} as const;');
    lines.push('');

    // Generate type
    lines.push(`export type ${enumName} = typeof ${enumName}[keyof typeof ${enumName}];`);
    lines.push('');
  }

  // Add utility type for getting enum values as arrays (useful for select options)
  lines.push('// Utility function to get enum values as array');
  lines.push('export function getEnumValues<T extends Record<string, string>>(enumObj: T): T[keyof T][] {');
  lines.push('  return Object.values(enumObj) as T[keyof T][];');
  lines.push('}');
  lines.push('');

  // Add a comment about usage
  lines.push('/**');
  lines.push(' * Usage examples:');
  lines.push(' * ');
  lines.push(' * // Import in client component');
  lines.push(' * import { UserRole, PolicyStatus } from "@/lib/enums";');
  lines.push(' * ');
  lines.push(' * // Use in comparisons');
  lines.push(' * if (user.role === UserRole.ADMIN) { ... }');
  lines.push(' * ');
  lines.push(' * // Get all values for a select');
  lines.push(' * const roleOptions = getEnumValues(UserRole);');
  lines.push(' */');

  return lines.join('\n');
}

async function main() {
  try {
    console.log('üîç Extracting enums from Prisma client...');
    const enums = extractEnums();

    console.log(`üì¶ Found ${Object.keys(enums).length} enums:`, Object.keys(enums).join(', '));

    console.log('üìù Generating TypeScript file...');
    const content = generateEnumFile(enums);

    console.log(`üíæ Writing to ${OUTPUT_PATH}...`);
    writeFileSync(OUTPUT_PATH, content, 'utf-8');

    console.log('‚úÖ Successfully generated client-safe enums!');
    console.log(`üìÅ Output: ${OUTPUT_PATH}`);
  } catch (error) {
    console.error('‚ùå Error generating enums:', error);
    process.exit(1);
  }
}

// Run the script
main();